import React, { useState, useEffect, useRef } from 'react';
import { 
  Shield, RefreshCcw, Hand, Crown, 
  Dices, Skull, Coins, ArrowRight, Ban,
  RotateCcw, Snowflake, Ghost, X, Repeat,
  TowerControl, ScrollText, BookOpen, HelpCircle, List,
  Palette, Eye, Trash2
} from 'lucide-react';

// --- Constants ---
const WINNING_SCORE = 10;

// Theme Configurations
const THEMES = {
  casino: {
    name: 'Casino Night',
    appBg: "bg-slate-950",
    textMain: "text-slate-100",
    textSub: "text-slate-500",
    boardBg: "bg-[#1e3a2f]",
    boardBorder: "border-[#2c2825] ring-white/10",
    squareDark: "bg-emerald-800",
    squareLight: "bg-emerald-600",
    graveyardBg: "bg-slate-900 border-slate-800",
    headerGradient: "from-yellow-400 to-orange-600",
    highlight: "bg-yellow-500 ring-yellow-300",
    accentText: "text-yellow-400",
    guideBg: "bg-slate-800",
    cardBg: "bg-white",
    discardBg: "bg-slate-800"
  },
  wood: {
    name: 'Classic Wood',
    appBg: "bg-[#2d1b15]", 
    textMain: "text-amber-50",
    textSub: "text-amber-400/60",
    boardBg: "bg-[#4a3525]",
    boardBorder: "border-[#3e2723] ring-amber-100/20",
    squareDark: "bg-[#8d6e63]", 
    squareLight: "bg-[#d7ccc8]", 
    graveyardBg: "bg-[#3e2723] border-[#5d4037]",
    headerGradient: "from-amber-200 to-orange-400",
    highlight: "bg-amber-400 ring-amber-200",
    accentText: "text-amber-300",
    guideBg: "bg-[#3e2723]",
    cardBg: "bg-[#f5f5dc]", // Beige for cards
    discardBg: "bg-[#3e2723]"
  }
};

const INITIAL_BOARD_LAYOUT = [
  ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
  ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
  Array(8).fill(null),
  Array(8).fill(null),
  Array(8).fill(null),
  Array(8).fill(null),
  ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
  ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
];

const onBoard = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;

const renderPieceIcon = (code, sizeClass = "text-3xl sm:text-4xl", colorClass = null) => {
    if (!code) return null;
    const isWhite = code === code.toUpperCase();
    const icons = {
      P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔', 
      p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚'
    };
    const normalized = code.toUpperCase();
    const lookupKey = isWhite ? normalized : normalized.toLowerCase();
    const icon = icons[code] || icons[lookupKey] || '?';
    const defaultColor = isWhite ? 'text-white' : 'text-slate-900';
    const finalColor = colorClass || defaultColor;
    const scaleFix = code === 'p' ? "scale-[0.85]" : "scale-100";

    return <span className={`${sizeClass} ${scaleFix} inline-block select-none font-bold drop-shadow-md ${finalColor}`}>{icon}</span>;
};

// --- Sub-Components ---

const Modal = ({ title, children, onClose, wide = false, theme }) => (
  <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200">
    <div className={`${theme.guideBg} border ${theme.boardBorder} rounded-2xl w-full max-h-[85vh] flex flex-col shadow-2xl ${wide ? 'max-w-2xl' : 'max-w-md'}`}>
      <div className="p-4 border-b border-white/10 flex justify-between items-center bg-black/20 rounded-t-2xl">
        <h2 className={`text-xl font-bold uppercase tracking-wider ${theme.accentText}`}>{title}</h2>
        <button onClick={onClose} className={`p-1 hover:bg-white/10 rounded-full transition-colors ${theme.textMain}`}><X size={20}/></button>
      </div>
      <div className={`p-6 overflow-y-auto custom-scrollbar ${theme.textMain} space-y-4`}>
        {children}
      </div>
    </div>
  </div>
);

const CardBack = ({ count, theme }) => (
  <div className={`relative w-24 h-32 ${theme.name === 'Casino Night' ? 'bg-indigo-950 border-slate-800' : 'bg-[#3e2723] border-[#271c19]'} rounded-xl border-4 shadow-xl flex items-center justify-center group cursor-pointer overflow-hidden`}>
      <div className="absolute inset-0 opacity-10 bg-[url('https://www.transparenttextures.com/patterns/cubes.png')]"></div>
      <div className="absolute inset-0 border-2 border-white/10 rounded-lg m-1"></div>
      <div className="z-10 flex flex-col items-center opacity-50 group-hover:opacity-100 transition-opacity">
          <div className={`text-4xl mb-1 filter drop-shadow-lg ${theme.accentText}`}>♞</div>
          <div className={`text-[10px] font-black tracking-widest uppercase ${theme.textSub}`}>Vegas</div>
          <div className={`text-[8px] font-bold tracking-widest uppercase ${theme.textSub}`}>Chess</div>
      </div>
      {count > 1 && <div className={`absolute -right-1 -bottom-1 w-full h-full rounded-xl -z-10 ${theme.name === 'Casino Night' ? 'bg-indigo-950 border-slate-800' : 'bg-[#3e2723] border-[#271c19]'} border-4`}></div>}
      {count > 5 && <div className={`absolute -right-2 -bottom-2 w-full h-full rounded-xl -z-20 ${theme.name === 'Casino Night' ? 'bg-indigo-950 border-slate-800' : 'bg-[#3e2723] border-[#271c19]'} border-4`}></div>}
  </div>
);

const DiscardPile = ({ pile, onClick, theme }) => {
    if (pile.length === 0) {
        return (
            <div className={`w-24 h-32 rounded-xl border-2 border-dashed ${theme.name === 'Casino Night' ? 'border-slate-700' : 'border-[#5d4037]'} flex items-center justify-center`}>
                <span className={`text-[10px] uppercase font-bold ${theme.textSub}`}>Discard</span>
            </div>
        );
    }
    const topCard = pile[pile.length - 1];
    return (
        <div onClick={onClick} className={`relative w-24 h-32 ${theme.cardBg} rounded-xl shadow-md border cursor-pointer hover:scale-105 transition-transform`}>
            {/* Show content of top card simply */}
            <div className="flex flex-col items-center justify-center h-full p-2 opacity-50 hover:opacity-100 transition-opacity">
               <div className="scale-75">{topCard.icon}</div>
               <div className="text-[8px] font-black uppercase text-center leading-none mt-1 text-black">{topCard.name}</div>
            </div>
            <div className={`absolute inset-0 flex items-center justify-center font-bold text-xs uppercase -rotate-12 opacity-20 pointer-events-none text-black`}>Used</div>
        </div>
    );
};

const Die = ({ value, rolling }) => {
  const rotation = rolling ? Math.random() * 360 : 0;
  return (
    <div 
      className={`
        w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-br from-red-500 to-red-700 
        rounded-xl border-2 border-red-900 shadow-[inset_0_2px_4px_rgba(255,255,255,0.3),0_4px_8px_rgba(0,0,0,0.5)] 
        flex items-center justify-center text-white font-black text-xl sm:text-2xl 
        transition-all duration-100 ease-linear
        ${rolling ? 'scale-110 shadow-lg' : 'scale-100'}
      `}
      style={{ transform: `rotate(${rotation}deg)` }}
    >
      <span className="drop-shadow-md">{value}</span>
    </div>
  );
};

const MiniBoard = ({ piece, moves, theme }) => {
    const grid = Array(5).fill(null).map(() => Array(5).fill(null));
    const center = 2; 
    return (
        <div className={`p-2 rounded-lg border-2 ${theme.boardBorder} ${theme.boardBg} inline-block`}>
            <div className="grid grid-cols-5 gap-0.5">
                {grid.map((row, r) => row.map((_, c) => {
                    const isCenter = r === center && c === center;
                    const isMove = moves.some(m => m[0] === (r - center) && m[1] === (c - center));
                    const isBlack = (r + c) % 2 === 1;
                    let bg = isBlack ? theme.squareDark : theme.squareLight;
                    if (isMove) bg = theme.highlight;
                    
                    return (
                        <div key={`${r}-${c}`} className={`w-6 h-6 flex items-center justify-center ${bg} rounded-[2px]`}>
                            {isCenter && renderPieceIcon(piece, "text-xl")}
                            {isMove && <div className="w-2 h-2 bg-black/20 rounded-full"></div>}
                        </div>
                    );
                }))}
            </div>
        </div>
    );
};

export default function VegasChess() {
  const [themeMode, setThemeMode] = useState('casino'); 
  const theme = THEMES[themeMode];

  const [gamePhase, setGamePhase] = useState('start'); 
  const [board, setBoard] = useState([]);
  const [turn, setTurn] = useState('white');
  
  const [dice, setDice] = useState([1, 1]);
  const [isRolling, setIsRolling] = useState(false);
  const [diceMessage, setDiceMessage] = useState("");
  
  const [scores, setScores] = useState({ white: 0, black: 0 });
  const [scoreLogs, setScoreLogs] = useState({ white: [], black: [] }); 
  const [stats, setStats] = useState({
     white: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } },
     black: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } }
  });
  const [history, setHistory] = useState([]); 

  const [activeModal, setActiveModal] = useState(null); 
  const [auditTarget, setAuditTarget] = useState(null); 
  const [showVisualGuide, setShowVisualGuide] = useState(false); 

  const [hands, setHands] = useState({ white: [], black: [] });
  const [selectedCard, setSelectedCard] = useState(null);
  const [effects, setEffects] = useState({
      white: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null },
      black: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null }
  });

  const [deck, setDeck] = useState([]);
  const [discardPile, setDiscardPile] = useState([]);

  const [selectedCell, setSelectedCell] = useState(null);
  const [validMoves, setValidMoves] = useState([]);

  useEffect(() => {
    resetGame();
  }, []);

  const toggleTheme = () => {
      setThemeMode(prev => prev === 'casino' ? 'wood' : 'casino');
  };

  const createCard = (type) => {
    const id = Math.random().toString(36).substr(2, 9);
    switch (type) {
      case 'bust': return { id, type: 'bust', name: 'Bust', desc: 'Demolish an adjacent enemy piece. No points awarded, but clears the path.', icon: <Skull size={24} className="text-red-600"/>, color: 'border-red-400' };
      case 'jackpot': return { id, type: 'jackpot', name: 'Jackpot', desc: 'Reach into the opponent\'s stash and steal 2 Points directly.', icon: <Coins size={24} className="text-yellow-600"/>, color: 'border-yellow-400' };
      case 'shuffle': return { id, type: 'shuffle', name: 'Shuffle', desc: 'Emergency! Swap your King with any of your other pieces.', icon: <RefreshCcw size={24} className="text-blue-600"/>, color: 'border-blue-400' };
      case 'rebuy': return { id, type: 'rebuy', name: 'Rebuy', desc: 'Reinforcements! Spawn a new Pawn on any empty square.', icon: <Shield size={24} className="text-emerald-600"/>, color: 'border-emerald-400' };
      case 'double': return { id, type: 'double', name: 'Double Down', desc: 'Adrenaline rush! Move the same piece twice this turn.', icon: <Repeat size={24} className="text-purple-600"/>, color: 'border-purple-400' };
      case 'cold': return { id, type: 'cold', name: 'Cold Deck', desc: 'Flash freeze! Target enemy piece cannot move next turn.', icon: <Snowflake size={24} className="text-cyan-600"/>, color: 'border-cyan-400' };
      case 'joker': return { id, type: 'joker', name: 'Joker', desc: 'Wildcard! One Pawn moves and captures like a Queen this turn.', icon: <Ghost size={24} className="text-pink-600"/>, color: 'border-pink-400' };
      case 'rewind': return { id, type: 'rewind', name: 'Rewind', desc: 'Time warp! Undo the previous turn completely.', icon: <RotateCcw size={24} className="text-orange-600"/>, color: 'border-orange-400' };
      case 'nope': return { id, type: 'nope', name: 'Nope', desc: 'Signal Jammer! Opponent cannot use Power Cards next turn.', icon: <Ban size={24} className="text-slate-600"/>, color: 'border-slate-400' };
      case 'fortify': return { id, type: 'fortify', name: 'Fortify', desc: 'Shields up! Select a piece to make it immune to capture.', icon: <TowerControl size={24} className="text-stone-600"/>, color: 'border-stone-400' };
      case 'decree': return { id, type: 'decree', name: 'Royal Decree', desc: 'Royal Decree! Teleport your King up to 2 squares instantly.', icon: <ScrollText size={24} className="text-amber-600"/>, color: 'border-amber-400' };
      default: return null;
    }
  };

  const generateDeck = () => {
      const distribution = [
          { type: 'rebuy', count: 5 }, { type: 'bust', count: 5 }, { type: 'nope', count: 5 },
          { type: 'shuffle', count: 3 }, { type: 'cold', count: 3 }, { type: 'fortify', count: 3 },
          { type: 'decree', count: 3 }, { type: 'double', count: 3 }, { type: 'joker', count: 2 },
          { type: 'rewind', count: 2 }, { type: 'jackpot', count: 2 },
      ];
      let newDeck = [];
      distribution.forEach(d => {
          for(let i=0; i<d.count; i++) newDeck.push(createCard(d.type));
      });
      return shuffle(newDeck);
  };

  const shuffle = (array) => {
      let currentIndex = array.length, randomIndex;
      while (currentIndex !== 0) {
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex--;
          [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
      }
      return array;
  };

  const drawCard = () => {
      let currentDeck = [...deck];
      let currentDiscard = [...discardPile];
      if (currentDeck.length === 0) {
          if (currentDiscard.length === 0) return { card: null, newDeck: [], newDiscard: [] }; 
          currentDeck = shuffle(currentDiscard);
          currentDiscard = [];
      }
      const card = currentDeck.pop();
      return { card, newDeck: currentDeck, newDiscard: currentDiscard };
  };

  const resetGame = () => {
    const initialBoard = INITIAL_BOARD_LAYOUT.map(row => [...row]);
    setBoard(initialBoard);
    setTurn('white');
    setScores({ white: 0, black: 0 });
    setScoreLogs({ white: [], black: [] });
    setStats({
      white: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } },
      black: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } }
    });
    setEffects({
        white: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null },
        black: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null }
    });
    setHistory([]); 
    
    const newDeck = generateDeck();
    const p1Card1 = newDeck.pop(); const p1Card2 = newDeck.pop();
    const p2Card1 = newDeck.pop(); const p2Card2 = newDeck.pop();

    setDeck(newDeck);
    setDiscardPile([]);
    setHands({ white: [p1Card1, p1Card2], black: [p2Card1, p2Card2] });
    
    setGamePhase('start');
    setDice([1, 1]);
    setIsRolling(false);
    setDiceMessage("");
    setSelectedCell(null);
    setValidMoves([]);
    setSelectedCard(null);
  };

  const addScore = (player, points, reason) => {
      if (points === 0) return;
      setScores(prev => ({ ...prev, [player]: prev[player] + points }));
      setScoreLogs(prev => ({
          ...prev,
          [player]: [...prev[player], { points, reason, turn: history.length + 1 }]
      }));
  };

  const saveState = () => {
      const snapshot = {
          board: board.map(r => [...r]),
          turn,
          scores: {...scores},
          scoreLogs: JSON.parse(JSON.stringify(scoreLogs)),
          stats: JSON.parse(JSON.stringify(stats)),
          hands: JSON.parse(JSON.stringify(hands)),
          effects: JSON.parse(JSON.stringify(effects)),
          deck: [...deck],
          discardPile: [...discardPile],
          gamePhase,
          dice,
          diceMessage
      };
      setHistory(prev => [...prev.slice(-4), snapshot]);
  };

  const rollDice = () => {
    if (gamePhase === 'action' || gamePhase === 'gameOver' || isRolling) return;
    
    setIsRolling(true);
    let rolls = 0;
    const interval = setInterval(() => {
      setDice([Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)]);
      rolls++;
      if (rolls > 12) {
        clearInterval(interval);
        setIsRolling(false);
        finalizeRoll();
      }
    }, 80);
  };

  const finalizeRoll = () => {
    saveState(); 
    const d1 = Math.ceil(Math.random() * 6);
    const d2 = Math.ceil(Math.random() * 6);
    setDice([d1, d2]);
    const sum = d1 + d2;
    const isSnakeEyes = d1 === 1 && d2 === 1;

    let msg = "";
    if (sum === 7 || sum === 11) {
      const result = drawCard();
      if (result.card) {
          setHands(prev => ({ ...prev, [turn]: [...prev[turn], result.card] }));
          setDeck(result.newDeck);
          setDiscardPile(result.newDiscard);
          msg = "Lucky 7/11! Drew a Card.";
      } else {
          msg = "Deck Empty!";
      }
    }
    if (isSnakeEyes) {
      setScores(prev => ({ ...prev, [turn]: Math.max(0, prev[turn] - 1) }));
      setScoreLogs(prev => ({ ...prev, [turn]: [...prev[turn], { points: -1, reason: "Snake Eyes", turn: history.length + 1 }] }));
      msg = "Snake Eyes! Lost 1 Point.";
    }
    
    setEffects(prev => ({
        ...prev,
        [turn]: { ...prev[turn], movesLeft: 1, jokerPiece: null, immunePiece: null } 
    }));

    setDiceMessage(msg || `Rolled ${sum}`);
    setGamePhase('action');
  };

  const getPiece = (r, c) => {
    if (!onBoard(r, c)) return null;
    const p = board[r][c];
    if (!p) return null;
    return { type: p.toLowerCase(), color: p === p.toUpperCase() ? 'white' : 'black', raw: p, r, c };
  };

  const isKingInCheck = (boardState, kingColor) => {
      let kPos;
      boardState.forEach((row, r) => row.forEach((p, c) => {
          if (p === (kingColor === 'white' ? 'K' : 'k')) kPos = [r, c];
      }));
      if (!kPos) return false;

      for (let r=0; r<8; r++) {
          for (let c=0; c<8; c++) {
              const p = boardState[r][c];
              if (p && (p === p.toUpperCase() ? 'white' : 'black') !== kingColor) {
                  const moves = getVegasMoves(r, c, {type: p.toLowerCase(), color: kingColor === 'white' ? 'black' : 'white', raw: p}, boardState, true);
                  if (moves.some(m => m[0] === kPos[0] && m[1] === kPos[1])) return true;
              }
          }
      }
      return false;
  };

  const getVegasMoves = (r, c, piece, currentBoard = board, ignoreSpecial = false) => {
    const moves = [];
    
    const isJoker = !ignoreSpecial && effects[piece.color].jokerPiece && effects[piece.color].jokerPiece[0] === r && effects[piece.color].jokerPiece[1] === c;
    const isFrozen = !ignoreSpecial && effects[piece.color].frozenPiece && effects[piece.color].frozenPiece[0] === r && effects[piece.color].frozenPiece[1] === c;

    if (isFrozen) return [];

    const isImmune = (tr, tc) => {
       if (ignoreSpecial) return false; 
       const targetP = currentBoard[tr][tc];
       if (!targetP) return false;
       const tColor = targetP === targetP.toUpperCase() ? 'white' : 'black';
       const imm = effects[tColor].immunePiece;
       return imm && imm[0] === tr && imm[1] === tc;
    };

    const check = (tr, tc) => {
      if (!onBoard(tr, tc)) return;
      const target = currentBoard[tr][tc];
      if (!target) {
         moves.push([tr, tc]);
      } else {
         if ((target === target.toUpperCase() ? 'white' : 'black') !== piece.color) {
             if (!isImmune(tr, tc)) moves.push([tr, tc]);
         }
      }
    };
    
    const slide = (dr, dc, limit = 3) => {
      for (let i = 1; i <= limit; i++) {
        const tr = r + (dr * i);
        const tc = c + (dc * i);
        if (!onBoard(tr, tc)) break;
        const target = currentBoard[tr][tc];
        if (!target) { 
            moves.push([tr, tc]); 
        } else {
          if ((target === target.toUpperCase() ? 'white' : 'black') !== piece.color) {
              if (!isImmune(tr, tc)) moves.push([tr, tc]);
          }
          break; 
        }
      }
    };

    const effectiveType = isJoker ? 'q' : piece.type;

    if (effectiveType === 'p') {
      const isWhite = piece.color === 'white';
      const forward = isWhite ? -1 : 1;
      const dirs = [[forward, 0], [forward, -1], [forward, 1], [0, -1], [0, 1]];
      dirs.forEach(d => check(r + d[0], c + d[1]));
    }
    else if (effectiveType === 'n') {
      const jumps = [[-2, 0], [2, 0], [0, -2], [0, 2], [-2, -2], [-2, 2], [2, -2], [2, 2]];
      jumps.forEach(d => check(r + d[0], c + d[1]));
    }
    else if (effectiveType === 'b') [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(d => slide(d[0], d[1], 3));
    else if (effectiveType === 'r') [[1,0], [-1,0], [0,1], [0,-1]].forEach(d => slide(d[0], d[1], 3));
    else if (effectiveType === 'q') [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(d => slide(d[0], d[1], 3));
    else if (effectiveType === 'k') [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(d => slide(d[0], d[1], 1));

    return moves;
  };

  const handleBoardClick = (r, c) => {
    if (gamePhase !== 'action' || isRolling) return;
    if (selectedCard) { handleCardAction(r, c); return; }

    const clickedPiece = getPiece(r, c);
    
    if (clickedPiece && clickedPiece.color === turn) {
      setSelectedCell([r, c]);
      setValidMoves(getVegasMoves(r, c, clickedPiece));
      return;
    }

    if (selectedCell) {
      const isMoveValid = validMoves.some(m => m[0] === r && m[1] === c);
      if (isMoveValid) { executeMove(selectedCell, [r, c]); }
      else { setSelectedCell(null); setValidMoves([]); }
    }
  };

  const executeMove = (from, to) => {
    const newBoard = board.map(row => [...row]);
    const piece = newBoard[from[0]][from[1]];
    const target = newBoard[to[0]][to[1]];
    
    newBoard[to[0]][to[1]] = piece;
    newBoard[from[0]][from[1]] = null;
    
    if (piece.toLowerCase() === 'p') {
        if ((turn === 'white' && to[0] === 0) || (turn === 'black' && to[0] === 7)) {
            newBoard[to[0]][to[1]] = turn === 'white' ? 'Q' : 'q';
        }
    }

    setBoard(newBoard);
    
    let logMessage = "";
    const currentStats = stats[turn];
    const newCounts = { ...currentStats.counts };
    const newHistory = [...currentStats.history];

    const enemyColor = turn === 'white' ? 'black' : 'white';
    if (isKingInCheck(newBoard, enemyColor)) {
        addScore(turn, 1, "King Checked");
        logMessage = "Check (+1)! ";
    }

    if (target) {
      const type = target.toLowerCase();
      const majors = ['n', 'b', 'r'];
      newCounts[type] = (newCounts[type] || 0) + 1;
      newHistory.push(type);

      if (type === 'q') { 
          addScore(turn, 2, "Queen Captured"); 
          logMessage += "Queen (+2)! "; 
      }
      if (type === 'p') {
          if (newCounts.p === 4) { addScore(turn, 1, "4-Pawn Collection"); logMessage += "4th Pawn (+1)! "; }
          if (newHistory.slice(-3).every(t => t === 'p') && newHistory.length >= 3) { addScore(turn, 1, "3-Pawn Streak"); logMessage += "Pawn Streak (+1)! "; }
      }
      if (majors.includes(type)) {
          if ((newCounts.n + newCounts.b + newCounts.r) === 3) { addScore(turn, 2, "3-Major Collection"); logMessage += "Major Set (+2)! "; }
          if (newHistory.slice(-2).every(t => majors.includes(t)) && newHistory.length >= 2) { addScore(turn, 1, "2-Major Streak"); logMessage += "Major Streak (+1)! "; }
      }
      
      if (type === 'k') { setGamePhase('gameOver'); setDiceMessage(`${turn.toUpperCase()} WINS! (Knockout)`); return; }
    }

    setStats(prev => ({ ...prev, [turn]: { history: newHistory, counts: newCounts } }));
    if (logMessage) setDiceMessage(logMessage);

    if (effects[turn].movesLeft > 1) {
        setEffects(prev => ({...prev, [turn]: {...prev[turn], movesLeft: prev[turn].movesLeft - 1}}));
        setSelectedCell(null);
        setValidMoves([]);
    } else {
        endTurn();
    }
  };

  useEffect(() => {
      if (scores.white >= WINNING_SCORE) { setGamePhase('gameOver'); setDiceMessage("WHITE WINS! (Jackpot)"); }
      if (scores.black >= WINNING_SCORE) { setGamePhase('gameOver'); setDiceMessage("BLACK WINS! (Jackpot)"); }
  }, [scores]);

  const endTurn = () => {
    setSelectedCell(null);
    setValidMoves([]);
    setSelectedCard(null);
    
    setEffects(prev => ({
        ...prev,
        [turn]: { ...prev[turn], jammed: false, frozenPiece: null, movesLeft: 1, immunePiece: null } 
    }));

    const nextTurn = turn === 'white' ? 'black' : 'white';
    setTurn(nextTurn);
    setGamePhase('roll');
    setTimeout(() => { if (gamePhase !== 'gameOver') setDiceMessage("Roll the dice!"); }, 1000);
  };

  // --- Card Logic ---
  const activateCard = (card) => {
    if (gamePhase !== 'action' || isRolling) return;
    if (effects[turn].jammed) { setDiceMessage("NOPE! You're blocked."); return; }
    if (selectedCard && selectedCard.id === card.id) { setSelectedCard(null); return; }

    if (card.type === 'jackpot') {
      const opp = turn === 'white' ? 'black' : 'white';
      const amt = Math.min(2, scores[opp]);
      setScores(prev => ({ ...prev, [turn]: prev[turn] + amt, [opp]: prev[opp] - amt }));
      setScoreLogs(prev => ({ 
          ...prev, 
          [turn]: [...prev[turn], { points: amt, reason: "Jackpot Steal", turn: history.length }],
          [opp]: [...prev[opp], { points: -amt, reason: "Stolen by Jackpot", turn: history.length }]
      }));
      setDiceMessage(`Stole ${amt} pts!`);
      discardAndEnd(card);
      return;
    }
    if (card.type === 'rewind') {
       if (history.length > 0) {
           const restore = history[history.length - 1]; 
           setBoard(restore.board);
           setScores(restore.scores);
           setScoreLogs(restore.scoreLogs);
           setStats(restore.stats);
           setHands(prev => ({ ...prev, [turn]: prev[turn].filter(c => c.id !== card.id) }));
           setDiscardPile(prev => [...prev, card]); 
           setDiceMessage("Rewind! Time reversed.");
           return;
       } else {
           setDiceMessage("Nothing to undo!");
       }
       return;
    }
    if (card.type === 'double') {
        setEffects(prev => ({ ...prev, [turn]: { ...prev[turn], movesLeft: 2 } }));
        setDiceMessage("Double Down! 2 Moves.");
        discardAndEnd(card, false); 
        return;
    }
    if (card.type === 'nope') {
        const opp = turn === 'white' ? 'black' : 'white';
        setEffects(prev => ({ ...prev, [opp]: { ...prev[opp], jammed: true } }));
        setDiceMessage("Nope! Enemy blocked.");
        discardAndEnd(card);
        return;
    }
    if (card.type === 'decree') {
        setSelectedCard(card);
        setDiceMessage("Select Empty Spot (Range 2)");
        return;
    }

    setSelectedCard(card);
    setDiceMessage(card.desc);
  };

  const handleCardAction = (r, c) => {
    const targetPiece = getPiece(r, c);
    const newBoard = board.map(row => [...row]);
    let success = false;

    if (selectedCard.type === 'bust') {
      if (targetPiece && targetPiece.color !== turn && targetPiece.type !== 'k') {
        newBoard[r][c] = null;
        success = true;
      }
    } 
    else if (selectedCard.type === 'rebuy') {
      if (!targetPiece) {
        newBoard[r][c] = turn === 'white' ? 'P' : 'p';
        success = true;
      }
    } 
    else if (selectedCard.type === 'shuffle') {
      if (targetPiece && targetPiece.type !== 'k') {
        let kr, kc;
        board.forEach((row, ir) => row.forEach((p, ic) => {
          if (p === (turn === 'white' ? 'K' : 'k')) { kr = ir; kc = ic; }
        }));
        if (kr !== undefined) {
           const temp = newBoard[r][c];
           newBoard[r][c] = newBoard[kr][kc];
           newBoard[kr][kc] = temp;
           success = true;
        }
      }
    }
    else if (selectedCard.type === 'cold') {
        if (targetPiece && targetPiece.color !== turn) {
            setEffects(prev => ({ 
                ...prev, 
                [targetPiece.color]: { ...prev[targetPiece.color], frozenPiece: [r, c] } 
            }));
            setDiceMessage("Frozen!");
            discardAndEnd(selectedCard);
            return; 
        }
    }
    else if (selectedCard.type === 'joker') {
        if (targetPiece && targetPiece.color === turn && targetPiece.type === 'p') {
            setEffects(prev => ({
                ...prev,
                [turn]: { ...prev[turn], jokerPiece: [r, c] }
            }));
            setDiceMessage("Pawn Powered Up!");
            discardAndEnd(selectedCard, false); 
            return;
        }
    }
    else if (selectedCard.type === 'fortify') {
        if (targetPiece && targetPiece.color === turn) {
            setEffects(prev => ({
                ...prev,
                [turn]: { ...prev[turn], immunePiece: [r, c] }
            }));
            setDiceMessage("Fortified!");
            discardAndEnd(selectedCard);
            return;
        }
    }
    else if (selectedCard.type === 'decree') {
        let kr, kc;
        board.forEach((row, ir) => row.forEach((p, ic) => {
          if (p === (turn === 'white' ? 'K' : 'k')) { kr = ir; kc = ic; }
        }));
        if (!targetPiece && Math.abs(r - kr) <= 2 && Math.abs(c - kc) <= 2) {
             newBoard[r][c] = newBoard[kr][kc];
             newBoard[kr][kc] = null;
             success = true;
             setDiceMessage("Decree Enacted!");
        }
    }

    if (success) {
      setBoard(newBoard);
      discardAndEnd(selectedCard);
    } else {
      setDiceMessage("Invalid Target!");
    }
  };

  const discardAndEnd = (card, shouldEndTurn = true) => {
    setHands(prev => ({ ...prev, [turn]: prev[turn].filter(c => c.id !== card.id) }));
    setDiscardPile(prev => [...prev, card]);
    setSelectedCard(null);
    if (shouldEndTurn) endTurn();
  };

  const getSquareStyle = (r, c) => {
    const isBlack = (r + c) % 2 === 1;
    let style = isBlack ? theme.squareDark : theme.squareLight;
    if (selectedCell && selectedCell[0] === r && selectedCell[1] === c) style = theme.highlight;
    else if (validMoves.some(m => m[0] === r && m[1] === c)) {
      const target = getPiece(r, c);
      style = target ? 'bg-red-500 ring-4 ring-red-300' : 'bg-green-400 ring-4 ring-green-200';
    }
    const p = getPiece(r, c);
    if (p) {
        if (effects[p.color].frozenPiece && effects[p.color].frozenPiece[0] === r && effects[p.color].frozenPiece[1] === c) {
            style += ' ring-4 ring-cyan-400 opacity-70';
        }
        if (effects[p.color].jokerPiece && effects[p.color].jokerPiece[0] === r && effects[p.color].jokerPiece[1] === c) {
            style += ' ring-4 ring-pink-500 animate-pulse';
        }
        if (effects[p.color].immunePiece && effects[p.color].immunePiece[0] === r && effects[p.color].immunePiece[1] === c) {
            style += ' ring-4 ring-stone-400';
        }
    }
    if (selectedCard) {
      if (selectedCard.type === 'bust' && p && p.color !== turn && p.type !== 'k') style = 'bg-red-600 animate-pulse cursor-crosshair';
      if (selectedCard.type === 'rebuy' && !p) style = 'bg-green-400 animate-pulse cursor-copy';
      if (selectedCard.type === 'shuffle' && p) style = 'bg-purple-500 animate-pulse';
      if (selectedCard.type === 'cold' && p && p.color !== turn) style = 'bg-cyan-500 animate-pulse';
      if (selectedCard.type === 'joker' && p && p.color === turn && p.type === 'p') style = 'bg-pink-500 animate-pulse';
      if (selectedCard.type === 'fortify' && p && p.color === turn) style = 'bg-stone-500 animate-pulse';
      if (selectedCard.type === 'decree' && !p) style += ' cursor-pointer hover:bg-amber-500/50';
    }
    return style;
  };

  return (
    <div className={`min-h-screen ${theme.appBg} ${theme.textMain} font-sans flex flex-col items-center p-4 selection:bg-yellow-500/30 relative overflow-hidden transition-colors duration-500`}>
      
      {/* Top Navigation Bar - Preventing overlap */}
      <div className={`w-full max-w-4xl flex justify-between items-center mb-6 p-2 rounded-lg ${theme.name === 'Casino Night' ? 'bg-slate-900/50' : 'bg-black/20'} backdrop-blur-sm border ${theme.boardBorder}`}>
          <div className="flex gap-2">
              <button onClick={() => setActiveModal('rules')} className={`p-2 rounded-full hover:bg-white/10 transition-colors ${theme.textSub} hover:${theme.textMain}`} title="Rules">
                  <BookOpen size={20} />
              </button>
              <button onClick={() => setActiveModal('scoring')} className={`p-2 rounded-full hover:bg-white/10 transition-colors ${theme.accentText}`} title="Scoring">
                  <HelpCircle size={20} />
              </button>
              <button onClick={toggleTheme} className="p-2 rounded-full hover:bg-white/10 transition-colors text-purple-400" title="Switch Theme">
                  <Palette size={20} />
              </button>
          </div>
          <div className="text-xs font-bold tracking-widest opacity-50 uppercase">{theme.name}</div>
      </div>

      {/* Start Screen */}
      {gamePhase === 'start' && (
        <div className={`absolute inset-0 z-50 ${theme.appBg}/95 flex flex-col items-center justify-center p-6 text-center`}>
          <h1 className={`text-6xl font-black text-transparent bg-clip-text bg-gradient-to-br ${theme.headerGradient} mb-6 drop-shadow-lg`}>
            VEGAS CHESS
          </h1>
          <button onClick={() => setGamePhase('roll')} className="px-10 py-4 bg-gradient-to-r from-yellow-500 to-orange-500 text-black font-black text-2xl rounded-full shadow-2xl hover:scale-105 transition-transform flex items-center gap-3">
            PLAY NOW <ArrowRight />
          </button>
        </div>
      )}

      {/* Header */}
      <div className="w-full max-w-4xl flex justify-between items-end mb-4 px-2">
        <div className={`flex flex-col items-center p-3 rounded-xl border-2 transition-all cursor-pointer hover:bg-white/5 ${turn === 'black' ? 'border-yellow-500 bg-black/30' : 'border-transparent'}`}
             onClick={() => { setAuditTarget('black'); setActiveModal('audit'); }}>
          <div className={`text-xs font-bold uppercase tracking-widest ${theme.textSub} mb-1`}>Black</div>
          <div className="text-4xl font-black text-red-500 flex items-center gap-2">{scores.black} <span className={`text-sm ${theme.textSub} font-medium`}>/ 10</span></div>
          {effects.black.jammed && <div className="text-xs bg-slate-700 text-slate-300 px-2 py-0.5 rounded mt-1">NOPE'D</div>}
        </div>

        <div className="flex flex-col items-center gap-2 mb-2">
           <div className={`text-sm font-bold tracking-widest uppercase animate-pulse ${theme.accentText}`}>{diceMessage}</div>
           {gamePhase !== 'action' && gamePhase !== 'gameOver' && !isRolling ? (
             <button onClick={rollDice} className="bg-blue-600 hover:bg-blue-500 text-white px-8 py-2 rounded-full font-bold shadow-lg shadow-blue-500/30 transition-transform hover:scale-105 active:scale-95 flex items-center gap-2"><Dices size={20} /> ROLL</button>
           ) : (
             <div className={`flex gap-4 ${theme.graveyardBg} px-6 py-2 rounded-full shadow-inner border border-white/5`}>
                <Die value={dice[0]} rolling={isRolling} />
                <Die value={dice[1]} rolling={isRolling} />
             </div>
           )}
        </div>

        <div className={`flex flex-col items-center p-3 rounded-xl border-2 transition-all cursor-pointer hover:bg-white/5 ${turn === 'white' ? 'border-yellow-500 bg-black/30' : 'border-transparent'}`}
             onClick={() => { setAuditTarget('white'); setActiveModal('audit'); }}>
          <div className={`text-xs font-bold uppercase tracking-widest ${theme.textSub} mb-1`}>White</div>
          <div className="text-4xl font-black text-blue-500 flex items-center gap-2">{scores.white} <span className={`text-sm ${theme.textSub} font-medium`}>/ 10</span></div>
          {effects.white.jammed && <div className="text-xs bg-slate-700 text-slate-300 px-2 py-0.5 rounded mt-1">NOPE'D</div>}
        </div>
      </div>

      {/* Main Game Area */}
      <div className="flex flex-col md:flex-row items-center gap-4">
          {/* Left Graveyard */}
          <div className={`${theme.graveyardBg} p-2 rounded-lg border w-full md:w-20 h-20 md:h-96 overflow-y-auto flex md:flex-col flex-row gap-1 items-center shadow-inner`}>
             <div className={`text-[10px] ${theme.textSub} uppercase font-bold mb-1 text-center w-full`}>Taken</div>
             {stats.black.history.map((p, i) => <div key={i} className="opacity-75">{renderPieceIcon(p.toUpperCase(), "text-2xl")}</div>)}
          </div>

          {/* Board */}
          <div className={`relative p-3 ${theme.boardBg} rounded-lg shadow-2xl border-[8px] ${theme.boardBorder}`}>
            <div className={`grid grid-cols-8 gap-0 border-2 ${theme.boardBorder}`}>
              {board.map((row, r) => row.map((cell, c) => (
                  <div key={`${r}-${c}`} onClick={() => handleBoardClick(r, c)} className={`w-10 h-10 sm:w-14 sm:h-14 flex items-center justify-center cursor-pointer transition-colors duration-150 ${getSquareStyle(r, c)}`}>
                    {renderPieceIcon(cell)}
                  </div>
              )))}
            </div>
            {gamePhase === 'gameOver' && (
              <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20 backdrop-blur-sm">
                 <Crown size={64} className="text-yellow-400 mb-4 animate-bounce" />
                 <div className="text-3xl font-black text-white text-center px-4 mb-6">{diceMessage}</div>
                 <button onClick={resetGame} className="px-6 py-2 bg-white text-black font-bold rounded-full hover:bg-slate-200">Play Again</button>
              </div>
            )}
          </div>

          {/* Right Graveyard */}
          <div className={`${theme.graveyardBg} p-2 rounded-lg border w-full md:w-20 h-20 md:h-96 overflow-y-auto flex md:flex-col flex-row gap-1 items-center shadow-inner`}>
             <div className={`text-[10px] ${theme.textSub} uppercase font-bold mb-1 text-center w-full`}>Taken</div>
             {stats.white.history.map((p, i) => <div key={i} className="opacity-75">{renderPieceIcon(p.toLowerCase(), "text-2xl", "text-slate-400")}</div>)}
          </div>
      </div>

      {/* Cards */}
      <div className="mt-6 w-full max-w-4xl px-4 flex gap-4">
        <div className="flex-1 overflow-x-auto pb-2">
            <div className="flex justify-between items-center mb-2">
              <span className={`text-xs font-bold ${theme.textSub} uppercase tracking-widest`}>{turn === 'white' ? "White's Hand" : "Black's Hand"}</span>
              {effects[turn].movesLeft > 1 && <span className="text-xs font-bold text-purple-400 animate-pulse">DOUBLE MOVE ACTIVE</span>}
            </div>

            <div className="flex gap-3 h-40 items-center">
               {hands[turn].length === 0 && (
                 <div className={`w-full text-center ${theme.textSub} text-sm italic border-2 border-dashed border-slate-700 rounded-lg py-8`}>No cards. Roll a 7 or 11!</div>
               )}

               {hands[turn].map((card) => (
                 <div key={card.id} onClick={() => activateCard(card)}
                   className={`relative min-w-[120px] w-32 h-40 ${theme.cardBg} rounded-xl shadow-xl cursor-pointer transition-all duration-200 flex flex-col items-center justify-between p-3 select-none border-b-4 group ${selectedCard && selectedCard.id === card.id ? '-translate-y-4 border-yellow-500 shadow-yellow-500/50 z-10' : gamePhase === 'action' ? `hover:-translate-y-2 hover:shadow-2xl ${card.color}` : 'opacity-50 grayscale border-slate-200'}`}>
                    <div className="text-[10px] font-bold text-slate-400 self-start uppercase tracking-wider">{card.type}</div>
                    <div className="mb-1 bg-slate-50 p-3 rounded-full shadow-inner group-hover:scale-110 transition-transform">{card.icon}</div>
                    <div className="text-xs font-black text-slate-800 uppercase tracking-wider text-center leading-none mb-1">{card.name}</div>
                    <div className="text-[9px] text-center text-slate-500 leading-tight border-t border-slate-200 pt-1 w-full">{card.desc}</div>
                 </div>
               ))}
            </div>
        </div>

        {/* Right Side Stacks */}
        <div className="flex flex-col gap-2 items-center justify-end pb-2">
            {/* Discard Pile */}
            <DiscardPile pile={discardPile} theme={theme} onClick={() => { setAuditTarget('discard'); setActiveModal('audit'); }} />
            
            {/* Draw Pile */}
            <div className="relative">
                <CardBack count={deck.length} theme={theme} />
                <div className={`text-[10px] ${theme.textSub} font-bold mt-1 text-center uppercase tracking-wider`}>{deck.length} Cards</div>
            </div>
        </div>
      </div>

      {/* Modals */}
      {activeModal === 'rules' && (
          <Modal title="Vegas Chess Rules" onClose={() => { setActiveModal(null); setShowVisualGuide(false); }} wide={showVisualGuide} theme={theme}>
              {!showVisualGuide ? (
                  <>
                      <h3 className={`font-bold ${theme.textMain}`}>Objective</h3>
                      <p>First to <span className={`font-bold ${theme.accentText}`}>10 Points</span> OR Capture the Enemy King.</p>
                      
                      <h3 className={`font-bold ${theme.textMain} mt-4 flex items-center justify-between`}>
                          Movement
                          <button 
                              onClick={() => setShowVisualGuide(true)} 
                              className="text-xs bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded-full flex items-center gap-2"
                          >
                              <Eye size={14}/> Visual Guide
                          </button>
                      </h3>
                      <ul className="list-disc pl-4 space-y-1">
                          <li><strong>Rook/Bishop/Queen:</strong> Max 3 squares move distance.</li>
                          <li><strong>Knight:</strong> Jumps exactly 2 squares (Cardinal or Diagonal). Hops over pieces.</li>
                          <li><strong>Pawn:</strong> Moves 1 square in 5 directions (Forward + Diagonals + Sides). No backward movement.</li>
                      </ul>
                      
                      <h3 className={`font-bold ${theme.textMain} mt-4`}>The Dice</h3>
                      <p>Roll at start of turn. <br/><strong>7 or 11:</strong> Draw Power Card. <br/><strong>Snake Eyes (1-1):</strong> Lose 1 Point.</p>
                  </>
              ) : (
                  <div className="space-y-6">
                      <div className="flex justify-between items-center mb-4 border-b border-white/10 pb-2">
                          <h3 className={`font-bold ${theme.textMain} text-lg`}>Movement Guide</h3>
                          <button onClick={() => setShowVisualGuide(false)} className={`text-sm ${theme.textSub} hover:${theme.textMain}`}>Back to Rules</button>
                      </div>
                      
                      <div className="grid grid-cols-1 sm:grid-cols-2 gap-6">
                          <div className="flex gap-4 items-center">
                              <MiniBoard piece="P" moves={[[0,-1],[0,1],[-1,0],[-1,-1],[-1,1]]} theme={theme} />
                              <div>
                                  <div className={`font-bold ${theme.textMain}`}>The Pawn</div>
                                  <div className={`text-xs ${theme.textSub}`}>Moves 1 sq: Forward, Diagonal, or Side. <br/>Promotes to Queen at end.</div>
                              </div>
                          </div>

                          <div className="flex gap-4 items-center">
                              <MiniBoard piece="N" moves={[[-2,0],[2,0],[0,-2],[0,2],[-2,-2],[-2,2],[2,-2],[2,2]]} theme={theme} />
                              <div>
                                  <div className={`font-bold ${theme.textMain}`}>The Knight</div>
                                  <div className={`text-xs ${theme.textSub}`}>"The Hopper". Jumps exactly 2 squares in any direction. Jumps over pieces.</div>
                              </div>
                          </div>

                          <div className="flex gap-4 items-center">
                              <MiniBoard piece="R" moves={[[-1,0],[-2,0],[-2,-1],[0,-1],[0,-2],[1,0],[2,0],[0,1],[0,2]]} theme={theme} />
                              <div>
                                  <div className={`font-bold ${theme.textMain}`}>Rook / Bishop / Queen</div>
                                  <div className={`text-xs ${theme.textSub}`}>Standard movement directions, but <span className={`font-bold ${theme.accentText}`}>Max 3 Squares</span> distance.</div>
                              </div>
                          </div>
                      </div>
                  </div>
              )}
          </Modal>
      )}

      {activeModal === 'scoring' && (
          <Modal title="Scoring Cheat Sheet" onClose={() => setActiveModal(null)} theme={theme}>
              <div className="space-y-3">
                  <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture Queen</span> <span className={`font-bold ${theme.accentText}`}>+2</span></div>
                  <div className="flex justify-between border-b border-white/10 pb-1"><span>Put King in Check</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                  <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 3 Pawns (Streak)</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                  <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 4 Pawns (Total)</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                  <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 2 Majors (Streak)</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                  <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 3 Majors (Total)</span> <span className={`font-bold ${theme.accentText}`}>+2</span></div>
              </div>
          </Modal>
      )}

      {activeModal === 'audit' && (
          <Modal title={auditTarget === 'discard' ? "Graveyard (Used Cards)" : `${auditTarget.toUpperCase()} Score Audit`} onClose={() => setActiveModal(null)} theme={theme}>
              {auditTarget === 'discard' ? (
                  discardPile.length === 0 ? <div className="text-center italic opacity-50">No cards played yet.</div> : (
                      <div className="grid grid-cols-2 gap-2">
                          {discardPile.slice().reverse().map((c, i) => (
                              <div key={i} className="flex items-center gap-2 p-2 bg-black/20 rounded">
                                  <div className="scale-75">{c.icon}</div>
                                  <div className="text-xs font-bold uppercase">{c.name}</div>
                              </div>
                          ))}
                      </div>
                  )
              ) : (
                  scoreLogs[auditTarget].length === 0 ? (
                      <div className="text-center opacity-50 italic py-4">No points scored yet.</div>
                  ) : (
                      <table className="w-full text-left text-sm">
                          <thead>
                              <tr className="border-b border-white/10 opacity-50"><th className="pb-2">Turn</th><th className="pb-2">Reason</th><th className="pb-2 text-right">Points</th></tr>
                          </thead>
                          <tbody>
                              {scoreLogs[auditTarget].map((log, i) => (
                                  <tr key={i} className="border-b border-white/5">
                                      <td className="py-2 opacity-50">{log.turn}</td>
                                      <td className="py-2">{log.reason}</td>
                                      <td className={`py-2 text-right font-bold ${log.points > 0 ? 'text-green-400' : 'text-red-400'}`}>{log.points > 0 ? '+' : ''}{log.points}</td>
                                  </tr>
                              ))}
                          </tbody>
                      </table>
                  )
              )}
          </Modal>
      )}

    </div>
  );
}
