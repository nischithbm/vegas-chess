<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vegas Chess</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons (UMD version for browser) -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/lucide-react/dist/lucide-react.min.js"></script>

    <style>
        /* Custom scrollbar for modals */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
    
    <!-- Import Map -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0"
      }
    }
    </script>
</head>
<body class="bg-slate-950">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
          Shield, RefreshCcw, Hand, Crown, 
          Dices, Skull, Coins, ArrowRight, Ban,
          RotateCcw, Snowflake, Ghost, X, Repeat,
          TowerControl, ScrollText, BookOpen, HelpCircle, List,
          Palette, Eye, Trash2, Diamond, Info
        } from 'lucide-react';

        // --- Constants ---
        const WINNING_SCORE = 10;

        // Theme Configurations
        const THEMES = {
          casino: {
            name: 'Casino Night',
            appBg: "bg-slate-950",
            textMain: "text-slate-100",
            textSub: "text-slate-500",
            boardBg: "bg-[#1e3a2f]",
            boardBorder: "border-[#2c2825] ring-white/10",
            squareDark: "bg-emerald-800",
            squareLight: "bg-emerald-600",
            graveyardBg: "bg-slate-900 border-slate-800",
            headerGradient: "from-yellow-400 to-orange-600",
            highlight: "bg-yellow-500 ring-yellow-300",
            accentText: "text-yellow-400",
            guideBg: "bg-slate-800",
            cardBg: "bg-white",
            discardBg: "bg-slate-800",
            capturedBlackPiece: "text-slate-400",
            capturedWhitePiece: "text-white"
          },
          wood: {
            name: 'Classic Wood',
            appBg: "bg-[#2d1b15]", 
            textMain: "text-amber-50",
            textSub: "text-amber-400/60",
            boardBg: "bg-[#4a3525]",
            boardBorder: "border-[#3e2723] ring-amber-100/20",
            squareDark: "bg-[#8d6e63]", 
            squareLight: "bg-[#d7ccc8]", 
            graveyardBg: "bg-[#3e2723] border-[#5d4037]",
            headerGradient: "from-amber-200 to-orange-400",
            highlight: "bg-amber-400 ring-amber-200",
            accentText: "text-amber-300",
            guideBg: "bg-[#3e2723]",
            cardBg: "bg-[#f5f5dc]", 
            discardBg: "bg-[#3e2723]",
            capturedBlackPiece: "text-black opacity-60",
            capturedWhitePiece: "text-white"
          }
        };

        const INITIAL_BOARD_LAYOUT = [
          ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
          ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
          Array(8).fill(null),
          Array(8).fill(null),
          Array(8).fill(null),
          Array(8).fill(null),
          ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
          ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
        ];

        // --- Card Definitions & Distribution ---
        const CARD_DEFINITIONS = {
            bust: { name: 'Bust', desc: 'Destroy adjacent enemy.', icon: <Skull size={20} className="text-slate-700"/>, color: 'border-red-400', rarity: 'Common' },
            jackpot: { name: 'Jackpot', desc: 'Steal 2 Points.', icon: <Coins size={20} className="text-slate-700"/>, color: 'border-yellow-400', rarity: 'Ultra Rare' },
            shuffle: { name: 'Shuffle', desc: 'Swap King w/ Piece.', icon: <RefreshCcw size={20} className="text-slate-700"/>, color: 'border-blue-400', rarity: 'Uncommon' },
            rebuy: { name: 'Rebuy', desc: 'Spawn a Pawn.', icon: <Shield size={20} className="text-slate-700"/>, color: 'border-emerald-400', rarity: 'Common' },
            double: { name: 'Double', desc: 'Move Twice.', icon: <Repeat size={20} className="text-slate-700"/>, color: 'border-purple-400', rarity: 'Rare' },
            cold: { name: 'Cold', desc: 'Freeze Enemy Piece.', icon: <Snowflake size={20} className="text-slate-700"/>, color: 'border-cyan-400', rarity: 'Uncommon' },
            joker: { name: 'Joker', desc: 'Pawn acts as Queen.', icon: <Ghost size={20} className="text-slate-700"/>, color: 'border-pink-400', rarity: 'Rare' },
            rewind: { name: 'Rewind', desc: 'Undo Last Turn.', icon: <RotateCcw size={20} className="text-slate-700"/>, color: 'border-orange-400', rarity: 'Rare' },
            nope: { name: 'Nope', desc: 'Block Enemy Cards.', icon: <Ban size={20} className="text-slate-700"/>, color: 'border-slate-400', rarity: 'Common' },
            fortify: { name: 'Fortify', desc: 'Piece Immune 1 Turn.', icon: <TowerControl size={20} className="text-slate-700"/>, color: 'border-stone-400', rarity: 'Uncommon' },
            decree: { name: 'Decree', desc: 'Teleport King.', icon: <ScrollText size={20} className="text-slate-700"/>, color: 'border-amber-400', rarity: 'Uncommon' }
        };

        const DECK_DISTRIBUTION = [
            { type: 'rebuy', count: 5 }, { type: 'bust', count: 5 }, { type: 'nope', count: 5 },
            { type: 'shuffle', count: 3 }, { type: 'cold', count: 3 }, { type: 'fortify', count: 3 },
            { type: 'decree', count: 3 }, { type: 'double', count: 3 }, { type: 'joker', count: 2 },
            { type: 'rewind', count: 2 }, { type: 'jackpot', count: 2 },
        ];

        const onBoard = (r, c) => r >= 0 && r < 8 && c >= 0 && c < 8;

        const renderPieceIcon = (code, sizeClass = "text-3xl sm:text-4xl", colorClass = null) => {
            if (!code) return null;
            const isWhite = code === code.toUpperCase();
            const icons = {
              P: '♙', R: '♖', N: '♘', B: '♗', Q: '♕', K: '♔', 
              p: '♟', r: '♜', n: '♞', b: '♝', q: '♛', k: '♚'
            };
            const normalized = code.toUpperCase();
            const lookupKey = isWhite ? normalized : normalized.toLowerCase();
            const icon = icons[code] || icons[lookupKey] || '?';
            const defaultColor = isWhite ? 'text-white' : 'text-slate-900';
            const finalColor = colorClass || defaultColor;
            
            const scaleFix = code === 'p' ? "scale-[0.85]" : "scale-100";

            return <span className={`${sizeClass} ${scaleFix} inline-block select-none font-bold drop-shadow-md ${finalColor} leading-none`}>{icon}</span>;
        };

        // --- Visual Components ---

        const PlayingCard = ({ card, onClick, isSelected, disabled, scale = 1, badge = null }) => {
            return (
                <div 
                    onClick={!disabled ? onClick : undefined}
                    style={{ transform: `scale(${scale})` }}
                    className={`
                        relative w-28 h-40 rounded-xl shadow-xl transition-all duration-200 cursor-pointer select-none origin-center
                        bg-slate-300 border-2 flex flex-col items-center justify-between p-3
                        ${isSelected ? '-translate-y-4 ring-4 ring-yellow-400 z-10' : 'hover:-translate-y-2'}
                        ${disabled ? 'opacity-50 cursor-default hover:translate-y-0' : 'border-slate-400'}
                    `}
                >
                    <div className="w-full text-center border-b border-slate-400/30 pb-1">
                        <div className="text-xs font-black text-slate-800 uppercase tracking-wider leading-none">
                            {card.name}
                        </div>
                    </div>
                    <div className="flex-1 flex items-center justify-center">
                        <div className="bg-slate-200/80 p-3 rounded-full shadow-inner transform scale-110">
                            {card.icon}
                        </div>
                    </div>
                    <div className="text-[9px] text-center text-slate-600 leading-tight w-full border-t border-slate-400/30 pt-2 px-0.5">
                        {card.desc}
                    </div>
                    {badge && (
                        <div className="absolute -top-2 -right-2 bg-yellow-500 text-slate-900 text-xs font-bold w-6 h-6 flex items-center justify-center rounded-full shadow-md border-2 border-slate-800">
                            {badge}
                        </div>
                    )}
                </div>
            );
        };

        const CardBack = ({ count, onClick }) => (
          <div 
            onClick={onClick} 
            className="relative w-24 h-32 bg-indigo-900 rounded-xl border-4 border-slate-800 shadow-xl flex items-center justify-center group cursor-pointer overflow-hidden transition-transform active:scale-95"
          >
              <div className="absolute inset-0 opacity-20 bg-[url('https://www.transparenttextures.com/patterns/cubes.png')]"></div>
              <div className="absolute inset-0 border-2 border-indigo-700 rounded-lg m-1"></div>
              <div className="z-10 flex flex-col items-center">
                  <div className="text-4xl text-yellow-500 mb-1 filter drop-shadow-md">♞</div>
                  <div className="text-[10px] font-black tracking-widest text-indigo-200 uppercase">Vegas</div>
                  <div className="text-[8px] font-bold tracking-widest text-indigo-300/60 uppercase">Chess</div>
              </div>
              <div className="absolute top-1 right-1"><Info size={12} className="text-indigo-400" /></div>
              {count > 1 && <div className="absolute -right-1 -bottom-1 w-full h-full rounded-xl -z-10 bg-indigo-900 border-4 border-slate-800"></div>}
              {count > 5 && <div className="absolute -right-2 -bottom-2 w-full h-full rounded-xl -z-20 bg-indigo-900 border-4 border-slate-800"></div>}
          </div>
        );

        const DiscardPile = ({ pile, onClick }) => {
            if (pile.length === 0) {
                return (
                    <div className="w-24 h-32 rounded-xl border-2 border-dashed border-slate-600/50 flex items-center justify-center">
                        <span className="text-[10px] uppercase font-bold text-slate-500">Discard</span>
                    </div>
                );
            }
            const topCard = pile[pile.length - 1];
            return (
                <div onClick={onClick} className="relative w-24 h-32 cursor-pointer transition-transform hover:scale-105">
                    <div className="transform scale-90 origin-top-left">
                        <PlayingCard card={topCard} disabled={true} />
                    </div>
                    <div className="absolute inset-0 flex items-center justify-center z-20 pointer-events-none">
                        <span className="text-slate-900/10 font-black text-2xl -rotate-12 border-4 border-slate-900/10 px-2 rounded uppercase">Used</span>
                    </div>
                </div>
            );
        };

        const Modal = ({ title, children, onClose, wide = false, theme }) => (
          <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200">
            <div className={`${theme.guideBg} border ${theme.boardBorder} rounded-2xl w-full max-h-[85vh] flex flex-col shadow-2xl ${wide ? 'max-w-4xl' : 'max-w-md'}`}>
              <div className="p-4 border-b border-white/10 flex justify-between items-center bg-black/20 rounded-t-2xl">
                <h2 className={`text-xl font-bold uppercase tracking-wider ${theme.accentText}`}>{title}</h2>
                <button onClick={onClose} className={`p-1 hover:bg-white/10 rounded-full transition-colors ${theme.textMain}`}><X size={20}/></button>
              </div>
              <div className={`p-6 overflow-y-auto custom-scrollbar ${theme.textMain} space-y-4`}>
                {children}
              </div>
            </div>
          </div>
        );

        const Die = ({ value, rolling }) => {
          const rotation = rolling ? Math.random() * 360 : 0;
          return (
            <div 
              className={`
                w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-br from-red-500 to-red-700 
                rounded-xl border-2 border-red-900 shadow-[inset_0_2px_4px_rgba(255,255,255,0.3),0_4px_8px_rgba(0,0,0,0.5)] 
                flex items-center justify-center text-white font-black text-xl sm:text-2xl 
                transition-all duration-100 ease-linear
                ${rolling ? 'scale-110 shadow-lg' : 'scale-100'}
              `}
              style={{ transform: `rotate(${rotation}deg)` }}
            >
              <span className="drop-shadow-md">{value}</span>
            </div>
          );
        };

        const MiniBoard = ({ piece, moves, theme }) => {
            const grid = Array(7).fill(null).map(() => Array(7).fill(null));
            const center = 3; 
            return (
                <div className={`p-2 rounded-lg border-2 ${theme.boardBorder} ${theme.boardBg} inline-block flex-none`}>
                    <div className="grid grid-cols-7 gap-0.5">
                        {grid.map((row, r) => row.map((_, c) => {
                            const isCenter = r === center && c === center;
                            const isMove = moves.some(m => m[0] === (r - center) && m[1] === (c - center));
                            const isBlack = (r + c) % 2 === 1;
                            let bg = isBlack ? theme.squareDark : theme.squareLight;
                            if (isMove) bg = theme.highlight;
                            
                            return (
                                <div key={`${r}-${c}`} className={`w-5 h-5 flex items-center justify-center ${bg} rounded-[1px]`}>
                                    {isCenter && <div className="scale-75 flex items-center justify-center">{renderPieceIcon(piece, "text-sm")}</div>}
                                    {isMove && <div className="w-1.5 h-1.5 bg-black/20 rounded-full"></div>}
                                </div>
                            );
                        }))}
                    </div>
                </div>
            );
        };

        function VegasChess() {
          const [themeMode, setThemeMode] = useState('wood'); 
          const theme = THEMES[themeMode];

          const [gamePhase, setGamePhase] = useState('start'); 
          const [board, setBoard] = useState([]);
          const [turn, setTurn] = useState('white');
          
          const [dice, setDice] = useState([1, 1]);
          const [isRolling, setIsRolling] = useState(false);
          const [diceMessage, setDiceMessage] = useState("");
          
          const [scores, setScores] = useState({ white: 0, black: 0 });
          const [scoreLogs, setScoreLogs] = useState({ white: [], black: [] }); 
          const [stats, setStats] = useState({
             white: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } },
             black: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } }
          });
          const [history, setHistory] = useState([]); 

          const [activeModal, setActiveModal] = useState(null); 
          const [auditTarget, setAuditTarget] = useState(null); 
          
          const [hands, setHands] = useState({ white: [], black: [] });
          const [selectedCard, setSelectedCard] = useState(null);
          const [effects, setEffects] = useState({
              white: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null },
              black: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null }
          });

          const [deck, setDeck] = useState([]);
          const [discardPile, setDiscardPile] = useState([]);

          const [selectedCell, setSelectedCell] = useState(null);
          const [validMoves, setValidMoves] = useState([]);

          useEffect(() => {
            resetGame();
          }, []);

          const toggleTheme = () => {
              setThemeMode(prev => prev === 'casino' ? 'wood' : 'casino');
          };

          const createCard = (type) => {
            const id = Math.random().toString(36).substr(2, 9);
            const def = CARD_DEFINITIONS[type];
            return { id, type, ...def };
          };

          const generateDeck = () => {
              let newDeck = [];
              DECK_DISTRIBUTION.forEach(d => {
                  for(let i=0; i<d.count; i++) newDeck.push(createCard(d.type));
              });
              return shuffle(newDeck);
          };

          const shuffle = (array) => {
              let currentIndex = array.length, randomIndex;
              while (currentIndex !== 0) {
                  randomIndex = Math.floor(Math.random() * currentIndex);
                  currentIndex--;
                  [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
              }
              return array;
          };

          const drawCard = () => {
              let currentDeck = [...deck];
              let currentDiscard = [...discardPile];
              if (currentDeck.length === 0) {
                  if (currentDiscard.length === 0) return { card: null, newDeck: [], newDiscard: [] }; 
                  currentDeck = shuffle(currentDiscard);
                  currentDiscard = [];
              }
              const card = currentDeck.pop();
              return { card, newDeck: currentDeck, newDiscard: currentDiscard };
          };

          const resetGame = () => {
            const initialBoard = INITIAL_BOARD_LAYOUT.map(row => [...row]);
            setBoard(initialBoard);
            setTurn('white');
            setScores({ white: 0, black: 0 });
            setScoreLogs({ white: [], black: [] });
            setStats({
              white: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } },
              black: { history: [], counts: { p:0, n:0, b:0, r:0, q:0 } }
            });
            setEffects({
                white: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null },
                black: { movesLeft: 1, jammed: false, frozenPiece: null, jokerPiece: null, immunePiece: null }
            });
            setHistory([]); 
            
            const newDeck = generateDeck();
            const p1Card1 = newDeck.pop(); const p1Card2 = newDeck.pop();
            const p2Card1 = newDeck.pop(); const p2Card2 = newDeck.pop();

            setDeck(newDeck);
            setDiscardPile([]);
            setHands({ white: [p1Card1, p1Card2], black: [p2Card1, p2Card2] });
            
            setGamePhase('start');
            setDice([1, 1]);
            setIsRolling(false);
            setDiceMessage("");
            setSelectedCell(null);
            setValidMoves([]);
            setSelectedCard(null);
          };

          const addScore = (player, points, reason) => {
              if (points === 0) return;
              setScores(prev => ({ ...prev, [player]: prev[player] + points }));
              setScoreLogs(prev => ({
                  ...prev,
                  [player]: [...prev[player], { points, reason, turn: history.length + 1 }]
              }));
          };

          const saveState = () => {
              const snapshot = {
                  board: board.map(r => [...r]),
                  turn,
                  scores: {...scores},
                  scoreLogs: JSON.parse(JSON.stringify(scoreLogs)),
                  stats: JSON.parse(JSON.stringify(stats)),
                  hands: JSON.parse(JSON.stringify(hands)),
                  effects: JSON.parse(JSON.stringify(effects)),
                  deck: [...deck],
                  discardPile: [...discardPile],
                  gamePhase,
                  dice,
                  diceMessage
              };
              setHistory(prev => [...prev.slice(-4), snapshot]);
          };

          const rollDice = () => {
            if (gamePhase === 'action' || gamePhase === 'gameOver' || isRolling) return;
            
            setIsRolling(true);
            let rolls = 0;
            const interval = setInterval(() => {
              setDice([Math.ceil(Math.random() * 6), Math.ceil(Math.random() * 6)]);
              rolls++;
              if (rolls > 12) {
                clearInterval(interval);
                setIsRolling(false);
                finalizeRoll();
              }
            }, 80);
          };

          const finalizeRoll = () => {
            saveState(); 
            const d1 = Math.ceil(Math.random() * 6);
            const d2 = Math.ceil(Math.random() * 6);
            setDice([d1, d2]);
            const sum = d1 + d2;
            const isSnakeEyes = d1 === 1 && d2 === 1;

            let msg = "";
            if (sum === 7 || sum === 11) {
              const result = drawCard();
              if (result.card) {
                  setHands(prev => ({ ...prev, [turn]: [...prev[turn], result.card] }));
                  setDeck(result.newDeck);
                  setDiscardPile(result.newDiscard);
                  msg = "Lucky 7/11! Drew a Card.";
              } else {
                  msg = "Deck Empty!";
              }
            }
            if (isSnakeEyes) {
              setScores(prev => ({ ...prev, [turn]: Math.max(0, prev[turn] - 1) }));
              setScoreLogs(prev => ({ ...prev, [turn]: [...prev[turn], { points: -1, reason: "Snake Eyes", turn: history.length + 1 }] }));
              msg = "Snake Eyes! Lost 1 Point.";
            }
            
            setEffects(prev => ({
                ...prev,
                [turn]: { ...prev[turn], movesLeft: 1, jokerPiece: null, immunePiece: null } 
            }));

            setDiceMessage(msg || `Rolled ${sum}`);
            setGamePhase('action');
          };

          const getPiece = (r, c) => {
            if (!onBoard(r, c)) return null;
            const p = board[r][c];
            if (!p) return null;
            return { type: p.toLowerCase(), color: p === p.toUpperCase() ? 'white' : 'black', raw: p, r, c };
          };

          const isKingInCheck = (boardState, kingColor) => {
              let kPos;
              boardState.forEach((row, r) => row.forEach((p, c) => {
                  if (p === (kingColor === 'white' ? 'K' : 'k')) kPos = [r, c];
              }));
              if (!kPos) return false;

              for (let r=0; r<8; r++) {
                  for (let c=0; c<8; c++) {
                      const p = boardState[r][c];
                      if (p && (p === p.toUpperCase() ? 'white' : 'black') !== kingColor) {
                          const moves = getVegasMoves(r, c, {type: p.toLowerCase(), color: kingColor === 'white' ? 'black' : 'white', raw: p}, boardState, true);
                          if (moves.some(m => m[0] === kPos[0] && m[1] === kPos[1])) return true;
                      }
                  }
              }
              return false;
          };

          const getVegasMoves = (r, c, piece, currentBoard = board, ignoreSpecial = false) => {
            const moves = [];
            const isJoker = !ignoreSpecial && effects[piece.color].jokerPiece && effects[piece.color].jokerPiece[0] === r && effects[piece.color].jokerPiece[1] === c;
            const isFrozen = !ignoreSpecial && effects[piece.color].frozenPiece && effects[piece.color].frozenPiece[0] === r && effects[piece.color].frozenPiece[1] === c;

            if (isFrozen) return [];

            const isImmune = (tr, tc) => {
               if (ignoreSpecial) return false; 
               const targetP = currentBoard[tr][tc];
               if (!targetP) return false;
               const tColor = targetP === targetP.toUpperCase() ? 'white' : 'black';
               const imm = effects[tColor].immunePiece;
               return imm && imm[0] === tr && imm[1] === tc;
            };

            const check = (tr, tc) => {
              if (!onBoard(tr, tc)) return;
              const target = currentBoard[tr][tc];
              if (!target) {
                 moves.push([tr, tc]);
              } else {
                 if ((target === target.toUpperCase() ? 'white' : 'black') !== piece.color) {
                     if (!isImmune(tr, tc)) moves.push([tr, tc]);
                 }
              }
            };
            
            const slide = (dr, dc, limit = 3) => {
              for (let i = 1; i <= limit; i++) {
                const tr = r + (dr * i);
                const tc = c + (dc * i);
                if (!onBoard(tr, tc)) break;
                const target = currentBoard[tr][tc];
                if (!target) { 
                    moves.push([tr, tc]); 
                } else {
                  if ((target === target.toUpperCase() ? 'white' : 'black') !== piece.color) {
                      if (!isImmune(tr, tc)) moves.push([tr, tc]);
                  }
                  break; 
                }
              }
            };

            const effectiveType = isJoker ? 'q' : piece.type;

            if (effectiveType === 'p') {
              const isWhite = piece.color === 'white';
              const forward = isWhite ? -1 : 1;
              const dirs = [[forward, 0], [forward, -1], [forward, 1], [0, -1], [0, 1]];
              dirs.forEach(d => check(r + d[0], c + d[1]));
            }
            else if (effectiveType === 'n') {
              const jumps = [[-2, 0], [2, 0], [0, -2], [0, 2], [-2, -2], [-2, 2], [2, -2], [2, 2]];
              jumps.forEach(d => check(r + d[0], c + d[1]));
            }
            else if (effectiveType === 'b') [[1,1], [1,-1], [-1,1], [-1,-1]].forEach(d => slide(d[0], d[1], 3));
            else if (effectiveType === 'r') [[1,0], [-1,0], [0,1], [0,-1]].forEach(d => slide(d[0], d[1], 3));
            else if (effectiveType === 'q') [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(d => slide(d[0], d[1], 3));
            else if (effectiveType === 'k') [[1,0], [-1,0], [0,1], [0,-1], [1,1], [1,-1], [-1,1], [-1,-1]].forEach(d => slide(d[0], d[1], 1));

            return moves;
          };

          const handleBoardClick = (r, c) => {
            if (gamePhase !== 'action' || isRolling) return;
            if (selectedCard) { handleCardAction(r, c); return; }

            const clickedPiece = getPiece(r, c);
            
            if (clickedPiece && clickedPiece.color === turn) {
              setSelectedCell([r, c]);
              setValidMoves(getVegasMoves(r, c, clickedPiece));
              return;
            }

            if (selectedCell) {
              const isMoveValid = validMoves.some(m => m[0] === r && m[1] === c);
              if (isMoveValid) { executeMove(selectedCell, [r, c]); }
              else { setSelectedCell(null); setValidMoves([]); }
            }
          };

          const executeMove = (from, to) => {
            const newBoard = board.map(row => [...row]);
            const piece = newBoard[from[0]][from[1]];
            const target = newBoard[to[0]][to[1]];
            
            newBoard[to[0]][to[1]] = piece;
            newBoard[from[0]][from[1]] = null;
            
            if (piece.toLowerCase() === 'p') {
                if ((turn === 'white' && to[0] === 0) || (turn === 'black' && to[0] === 7)) {
                    newBoard[to[0]][to[1]] = turn === 'white' ? 'Q' : 'q';
                }
            }

            setBoard(newBoard);
            
            let logMessage = "";
            const currentStats = stats[turn];
            const newCounts = { ...currentStats.counts };
            const newHistory = [...currentStats.history];

            const enemyColor = turn === 'white' ? 'black' : 'white';
            if (isKingInCheck(newBoard, enemyColor)) {
                addScore(turn, 1, "King Checked");
                logMessage = "Check (+1)! ";
            }

            if (target) {
              const type = target.toLowerCase();
              const majors = ['n', 'b', 'r'];
              newCounts[type] = (newCounts[type] || 0) + 1;
              newHistory.push(type);

              if (type === 'q') { 
                  addScore(turn, 2, "Queen Captured"); 
                  logMessage += "Queen (+2)! "; 
              }
              if (type === 'p') {
                  if (newCounts.p === 4) { addScore(turn, 1, "4-Pawn Collection"); logMessage += "4th Pawn (+1)! "; }
                  if (newHistory.slice(-3).every(t => t === 'p') && newHistory.length >= 3) { addScore(turn, 1, "3-Pawn Streak"); logMessage += "Pawn Streak (+1)! "; }
              }
              if (majors.includes(type)) {
                  if ((newCounts.n + newCounts.b + newCounts.r) === 3) { addScore(turn, 2, "3-Major Collection"); logMessage += "Major Set (+2)! "; }
                  if (newHistory.slice(-2).every(t => majors.includes(t)) && newHistory.length >= 2) { addScore(turn, 1, "2-Major Streak"); logMessage += "Major Streak (+1)! "; }
              }
              
              if (type === 'k') { setGamePhase('gameOver'); setDiceMessage(`${turn.toUpperCase()} WINS! (Knockout)`); return; }
            }

            setStats(prev => ({ ...prev, [turn]: { history: newHistory, counts: newCounts } }));
            if (logMessage) setDiceMessage(logMessage);

            if (effects[turn].movesLeft > 1) {
                setEffects(prev => ({...prev, [turn]: {...prev[turn], movesLeft: prev[turn].movesLeft - 1}}));
                setSelectedCell(null);
                setValidMoves([]);
            } else {
                endTurn();
            }
          };

          useEffect(() => {
              if (scores.white >= WINNING_SCORE) { setGamePhase('gameOver'); setDiceMessage("WHITE WINS! (Jackpot)"); }
              if (scores.black >= WINNING_SCORE) { setGamePhase('gameOver'); setDiceMessage("BLACK WINS! (Jackpot)"); }
          }, [scores]);

          const endTurn = () => {
            setSelectedCell(null);
            setValidMoves([]);
            setSelectedCard(null);
            
            setEffects(prev => ({
                ...prev,
                [turn]: { ...prev[turn], jammed: false, frozenPiece: null, movesLeft: 1, immunePiece: null } 
            }));

            const nextTurn = turn === 'white' ? 'black' : 'white';
            setTurn(nextTurn);
            setGamePhase('roll');
            setTimeout(() => { if (gamePhase !== 'gameOver') setDiceMessage("Roll the dice!"); }, 1000);
          };

          // --- Card Logic ---
          const activateCard = (card) => {
            if (gamePhase !== 'action' || isRolling) return;
            if (effects[turn].jammed) { setDiceMessage("NOPE! You're blocked."); return; }
            if (selectedCard && selectedCard.id === card.id) { setSelectedCard(null); return; }

            if (card.type === 'jackpot') {
              const opp = turn === 'white' ? 'black' : 'white';
              const amt = Math.min(2, scores[opp]);
              setScores(prev => ({ ...prev, [turn]: prev[turn] + amt, [opp]: prev[opp] - amt }));
              setScoreLogs(prev => ({ 
                  ...prev, 
                  [turn]: [...prev[turn], { points: amt, reason: "Jackpot Steal", turn: history.length }],
                  [opp]: [...prev[opp], { points: -amt, reason: "Stolen by Jackpot", turn: history.length }]
              }));
              setDiceMessage(`Stole ${amt} pts!`);
              discardAndEnd(card);
              return;
            }
            if (card.type === 'rewind') {
               if (history.length > 0) {
                   const restore = history[history.length - 1]; 
                   setBoard(restore.board);
                   setScores(restore.scores);
                   setScoreLogs(restore.scoreLogs);
                   setStats(restore.stats);
                   setHands(prev => ({ ...prev, [turn]: prev[turn].filter(c => c.id !== card.id) }));
                   setDiscardPile(prev => [...prev, card]); 
                   setDiceMessage("Rewind! Time reversed.");
                   return;
               } else {
                   setDiceMessage("Nothing to undo!");
               }
               return;
            }
            if (card.type === 'double') {
                setEffects(prev => ({ ...prev, [turn]: { ...prev[turn], movesLeft: 2 } }));
                setDiceMessage("Double Down! 2 Moves.");
                discardAndEnd(card, false); 
                return;
            }
            if (card.type === 'nope') {
                const opp = turn === 'white' ? 'black' : 'white';
                setEffects(prev => ({ ...prev, [opp]: { ...prev[opp], jammed: true } }));
                setDiceMessage("Nope! Enemy blocked.");
                discardAndEnd(card);
                return;
            }
            if (card.type === 'decree') {
                setSelectedCard(card);
                setDiceMessage("Select Empty Spot (Range 2)");
                return;
            }

            setSelectedCard(card);
            setDiceMessage(card.desc);
          };

          const handleCardAction = (r, c) => {
            const targetPiece = getPiece(r, c);
            const newBoard = board.map(row => [...row]);
            let success = false;

            if (selectedCard.type === 'bust') {
              if (targetPiece && targetPiece.color !== turn && targetPiece.type !== 'k') {
                newBoard[r][c] = null;
                success = true;
              }
            } 
            else if (selectedCard.type === 'rebuy') {
              if (!targetPiece) {
                newBoard[r][c] = turn === 'white' ? 'P' : 'p';
                success = true;
              }
            } 
            else if (selectedCard.type === 'shuffle') {
              if (targetPiece && targetPiece.type !== 'k') {
                let kr, kc;
                board.forEach((row, ir) => row.forEach((p, ic) => {
                  if (p === (turn === 'white' ? 'K' : 'k')) { kr = ir; kc = ic; }
                }));
                if (kr !== undefined) {
                   const temp = newBoard[r][c];
                   newBoard[r][c] = newBoard[kr][kc];
                   newBoard[kr][kc] = temp;
                   success = true;
                }
              }
            }
            else if (selectedCard.type === 'cold') {
                if (targetPiece && targetPiece.color !== turn) {
                    setEffects(prev => ({ 
                        ...prev, 
                        [targetPiece.color]: { ...prev[targetPiece.color], frozenPiece: [r, c] } 
                    }));
                    setDiceMessage("Frozen!");
                    discardAndEnd(selectedCard);
                    return; 
                }
            }
            else if (selectedCard.type === 'joker') {
                if (targetPiece && targetPiece.color === turn && targetPiece.type === 'p') {
                    setEffects(prev => ({
                        ...prev,
                        [turn]: { ...prev[turn], jokerPiece: [r, c] }
                    }));
                    setDiceMessage("Pawn Powered Up!");
                    discardAndEnd(selectedCard, false); 
                    return;
                }
            }
            else if (selectedCard.type === 'fortify') {
                if (targetPiece && targetPiece.color === turn) {
                    setEffects(prev => ({
                        ...prev,
                        [turn]: { ...prev[turn], immunePiece: [r, c] }
                    }));
                    setDiceMessage("Fortified!");
                    discardAndEnd(selectedCard);
                    return;
                }
            }
            else if (selectedCard.type === 'decree') {
                let kr, kc;
                board.forEach((row, ir) => row.forEach((p, ic) => {
                  if (p === (turn === 'white' ? 'K' : 'k')) { kr = ir; kc = ic; }
                }));
                if (!targetPiece && Math.abs(r - kr) <= 2 && Math.abs(c - kc) <= 2) {
                     newBoard[r][c] = newBoard[kr][kc];
                     newBoard[kr][kc] = null;
                     success = true;
                     setDiceMessage("Decree Enacted!");
                }
            }

            if (success) {
              setBoard(newBoard);
              discardAndEnd(selectedCard);
            } else {
              setDiceMessage("Invalid Target!");
            }
          };

          const discardAndEnd = (card, shouldEndTurn = true) => {
            setHands(prev => ({ ...prev, [turn]: prev[turn].filter(c => c.id !== card.id) }));
            setDiscardPile(prev => [...prev, card]);
            setSelectedCard(null);
            if (shouldEndTurn) endTurn();
          };

          const getSquareStyle = (r, c) => {
            const isBlack = (r + c) % 2 === 1;
            let style = isBlack ? theme.squareDark : theme.squareLight;
            if (selectedCell && selectedCell[0] === r && selectedCell[1] === c) style = theme.highlight;
            else if (validMoves.some(m => m[0] === r && m[1] === c)) {
              const target = getPiece(r, c);
              style = target ? 'bg-red-500 ring-4 ring-red-300' : 'bg-green-400 ring-4 ring-green-200';
            }
            const p = getPiece(r, c);
            if (p) {
                if (effects[p.color].frozenPiece && effects[p.color].frozenPiece[0] === r && effects[p.color].frozenPiece[1] === c) {
                    style += ' ring-4 ring-cyan-400 opacity-70';
                }
                if (effects[p.color].jokerPiece && effects[p.color].jokerPiece[0] === r && effects[p.color].jokerPiece[1] === c) {
                    style += ' ring-4 ring-pink-500 animate-pulse';
                }
                if (effects[p.color].immunePiece && effects[p.color].immunePiece[0] === r && effects[p.color].immunePiece[1] === c) {
                    style += ' ring-4 ring-stone-400';
                }
            }
            if (selectedCard) {
              if (selectedCard.type === 'bust' && p && p.color !== turn && p.type !== 'k') style = 'bg-red-600 animate-pulse cursor-crosshair';
              if (selectedCard.type === 'rebuy' && !p) style = 'bg-green-400 animate-pulse cursor-copy';
              if (selectedCard.type === 'shuffle' && p) style = 'bg-purple-500 animate-pulse';
              if (selectedCard.type === 'cold' && p && p.color !== turn) style = 'bg-cyan-500 animate-pulse';
              if (selectedCard.type === 'joker' && p && p.color === turn && p.type === 'p') style = 'bg-pink-500 animate-pulse';
              if (selectedCard.type === 'fortify' && p && p.color === turn) style = 'bg-stone-500 animate-pulse';
              if (selectedCard.type === 'decree' && !p) style += ' cursor-pointer hover:bg-amber-500/50';
            }
            return style;
          };

          return (
            <div className={`min-h-screen ${theme.appBg} ${theme.textMain} font-sans flex flex-col items-center p-4 selection:bg-yellow-500/30 relative overflow-hidden transition-colors duration-500`}>
              
              {/* Top Navigation Bar */}
              <div className={`w-full max-w-4xl flex justify-between items-center mb-6 p-2 rounded-lg ${theme.name === 'Casino Night' ? 'bg-slate-900/50' : 'bg-black/20'} backdrop-blur-sm border ${theme.boardBorder}`}>
                  <div className="flex gap-2">
                      <button onClick={toggleTheme} className="p-2 rounded-full hover:bg-white/10 transition-colors text-purple-400" title="Switch Theme">
                          <Palette size={20} />
                      </button>
                  </div>
                  <div className="text-xs font-bold tracking-widest opacity-50 uppercase">{theme.name}</div>
              </div>

              {/* Start Screen */}
              {gamePhase === 'start' && (
                <div className={`absolute inset-0 z-50 ${theme.appBg}/95 flex flex-col items-center justify-center p-6 text-center`}>
                  <h1 className={`text-6xl font-black text-transparent bg-clip-text bg-gradient-to-br ${theme.headerGradient} mb-6 drop-shadow-lg`}>
                    VEGAS CHESS
                  </h1>
                  <div className="flex flex-col gap-4 items-center">
                      <button onClick={() => setGamePhase('roll')} className="px-10 py-4 bg-gradient-to-r from-yellow-500 to-orange-500 text-black font-black text-2xl rounded-full shadow-2xl hover:scale-105 transition-transform flex items-center gap-3">
                        PLAY NOW <ArrowRight />
                      </button>
                      <button 
                          onClick={() => setActiveModal('rules')} 
                          className={`px-8 py-3 rounded-full border-2 border-white/10 hover:bg-white/10 ${theme.textMain} font-bold text-lg transition-all hover:scale-105 flex items-center gap-2`}
                      >
                          <BookOpen size={20} /> How to Play
                      </button>
                  </div>
                </div>
              )}

              {/* Header */}
              <div className="w-full max-w-4xl flex justify-between items-end mb-4 px-2">
                <div className={`flex flex-col items-center p-3 rounded-xl border-2 transition-all cursor-pointer hover:bg-white/5 ${turn === 'black' ? 'border-yellow-500 bg-black/30' : 'border-transparent'}`}
                     onClick={() => { setAuditTarget('black'); setActiveModal('audit'); }}>
                  <div className={`text-xs font-bold uppercase tracking-widest ${theme.textSub} mb-1`}>Black</div>
                  <div className="text-4xl font-black text-red-500 flex items-center gap-2">{scores.black} <span className={`text-sm ${theme.textSub} font-medium`}>/ 10</span></div>
                  {effects.black.jammed && <div className="text-xs bg-slate-700 text-slate-300 px-2 py-0.5 rounded mt-1">NOPE'D</div>}
                </div>

                <div className="flex flex-col items-center gap-2 mb-2">
                   <div className={`text-sm font-bold tracking-widest uppercase animate-pulse ${theme.accentText}`}>{diceMessage}</div>
                   {gamePhase !== 'action' && gamePhase !== 'gameOver' && !isRolling ? (
                     <button onClick={rollDice} className="bg-blue-600 hover:bg-blue-500 text-white px-8 py-2 rounded-full font-bold shadow-lg shadow-blue-500/30 transition-transform hover:scale-105 active:scale-95 flex items-center gap-2"><Dices size={20} /> ROLL</button>
                   ) : (
                     <div className={`flex gap-4 ${theme.graveyardBg} px-6 py-2 rounded-full shadow-inner border border-white/5`}>
                        <Die value={dice[0]} rolling={isRolling} />
                        <Die value={dice[1]} rolling={isRolling} />
                     </div>
                   )}
                </div>

                <div className={`flex flex-col items-center p-3 rounded-xl border-2 transition-all cursor-pointer hover:bg-white/5 ${turn === 'white' ? 'border-yellow-500 bg-black/30' : 'border-transparent'}`}
                     onClick={() => { setAuditTarget('white'); setActiveModal('audit'); }}>
                  <div className={`text-xs font-bold uppercase tracking-widest ${theme.textSub} mb-1`}>White</div>
                  <div className="text-4xl font-black text-blue-500 flex items-center gap-2">{scores.white} <span className={`text-sm ${theme.textSub} font-medium`}>/ 10</span></div>
                  {effects.white.jammed && <div className="text-xs bg-slate-700 text-slate-300 px-2 py-0.5 rounded mt-1">NOPE'D</div>}
                </div>
              </div>

              {/* Main Game Area */}
              <div className="flex flex-col md:flex-row items-center gap-6">
                  
                  {/* Left Sidebar: Combined Graveyard */}
                  <div className={`${theme.graveyardBg} p-4 rounded-xl border w-full md:w-32 h-20 md:h-[32rem] flex md:flex-col flex-row justify-between items-center shadow-2xl relative`}>
                      
                      {/* Top Half: Black's Loot (White Pieces) */}
                      <div className="flex flex-col items-center gap-1 w-full h-1/2 overflow-y-auto custom-scrollbar border-b border-white/5 pb-2">
                          <div className={`text-[10px] ${theme.textSub} uppercase font-bold mb-1 text-center w-full`}>Black Taken</div>
                          <div className="flex flex-wrap justify-center gap-1">
                              {stats.black.history.map((p, i) => (
                                  <div key={i} className="opacity-75 hover:scale-125 transition-transform">{renderPieceIcon(p.toUpperCase(), "text-2xl", theme.capturedWhitePiece)}</div>
                              ))}
                          </div>
                      </div>

                      {/* Bottom Half: White's Loot (Black Pieces) */}
                      <div className="flex flex-col items-center gap-1 w-full h-1/2 overflow-y-auto custom-scrollbar pt-2">
                          <div className="flex flex-wrap justify-center gap-1">
                              {stats.white.history.map((p, i) => (
                                  <div key={i} className="opacity-75 hover:scale-125 transition-transform">{renderPieceIcon(p.toLowerCase(), "text-2xl", theme.capturedBlackPiece)}</div>
                              ))}
                          </div>
                          <div className={`text-[10px] ${theme.textSub} uppercase font-bold mt-auto text-center w-full`}>White Taken</div>
                      </div>
                  </div>

                  {/* Board */}
                  <div className={`relative p-3 ${theme.boardBg} rounded-lg shadow-2xl border-[8px] ${theme.boardBorder}`}>
                    <div className={`grid grid-cols-8 gap-0 border-2 ${theme.boardBorder}`}>
                      {board.map((row, r) => row.map((cell, c) => (
                          <div key={`${r}-${c}`} onClick={() => handleBoardClick(r, c)} className={`w-10 h-10 sm:w-14 sm:h-14 flex items-center justify-center cursor-pointer transition-colors duration-150 ${getSquareStyle(r, c)}`}>
                            {renderPieceIcon(cell)}
                          </div>
                      )))}
                    </div>
                    {gamePhase === 'gameOver' && (
                      <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-20 backdrop-blur-sm">
                         <Crown size={64} className="text-yellow-400 mb-4 animate-bounce" />
                         <div className="text-3xl font-black text-white text-center px-4 mb-6">{diceMessage}</div>
                         <button onClick={resetGame} className="px-6 py-2 bg-white text-black font-bold rounded-full hover:bg-slate-200">Play Again</button>
                      </div>
                    )}
                  </div>

                  {/* Right Column: Deck & Discard */}
                  <div className="flex flex-col gap-6 h-[32rem] justify-center items-center">
                      
                      {/* How to Play Button */}
                      <button onClick={() => setActiveModal('rules')} className={`px-4 py-2 rounded-full bg-black/20 hover:bg-white/10 transition-colors ${theme.textMain} border border-white/10 flex items-center gap-2 font-bold text-sm mb-2`} title="Rules">
                          <BookOpen size={16} /> How to Play
                      </button>

                      {/* Deck */}
                      <div className="flex flex-col items-center">
                          <CardBack count={deck.length} theme={theme} onClick={() => setActiveModal('deck')} />
                          <div className={`text-[10px] ${theme.textSub} font-bold mt-1 text-center uppercase tracking-wider`}>{deck.length} Cards</div>
                      </div>

                      {/* Discard Pile */}
                      <div className="flex flex-col items-center">
                          <DiscardPile pile={discardPile} theme={theme} onClick={() => { setAuditTarget('discard'); setActiveModal('audit'); }} />
                      </div>
                  </div>
              </div>

              {/* Cards (Hand Only) */}
              <div className="mt-6 w-full max-w-4xl px-4 flex justify-center">
                <div className="w-full max-w-xl overflow-x-auto pb-2">
                    <div className="flex justify-between items-center mb-2">
                      <span className={`text-xs font-bold ${theme.textSub} uppercase tracking-widest`}>{turn === 'white' ? "White's Hand" : "Black's Hand"}</span>
                      {effects[turn].movesLeft > 1 && <span className="text-xs font-bold text-purple-400 animate-pulse">DOUBLE MOVE ACTIVE</span>}
                    </div>

                    <div className="flex gap-3 h-40 items-center justify-center">
                       {hands[turn].length === 0 && (
                         <div className={`w-full text-center ${theme.textSub} text-sm italic border-2 border-dashed border-slate-700 rounded-lg py-8`}>No cards. Roll a 7 or 11!</div>
                       )}

                       {hands[turn].map((card) => (
                         <div key={card.id} onClick={() => activateCard(card)}
                           className={`relative min-w-[120px] w-32 h-40 ${theme.cardBg} rounded-xl shadow-xl cursor-pointer transition-all duration-200 flex flex-col items-center justify-between p-3 select-none border-b-4 group ${selectedCard && selectedCard.id === card.id ? '-translate-y-4 border-yellow-500 shadow-yellow-500/50 z-10' : gamePhase === 'action' ? `hover:-translate-y-2 hover:shadow-2xl ${card.color}` : 'opacity-50 grayscale border-slate-200'}`}>
                            {/* Top Name */}
                            <div className="w-full text-center border-b border-slate-400/30 pb-1">
                                <div className="text-xs font-black text-slate-800 uppercase tracking-wider leading-none">
                                    {card.name}
                                </div>
                            </div>
                            <div className="mb-1 bg-slate-50 p-3 rounded-full shadow-inner group-hover:scale-110 transition-transform">{card.icon}</div>
                            <div className="text-[9px] text-center text-slate-500 leading-tight border-t border-slate-200 pt-1 w-full">{card.desc}</div>
                         </div>
                       ))}
                    </div>
                </div>
              </div>

              {/* Modals */}
              {activeModal === 'rules' && (
                  <Modal title="How to Play" onClose={() => setActiveModal(null)} wide={true} theme={theme}>
                      <div className="space-y-8">
                          <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                              <div>
                                  <h3 className={`font-bold ${theme.textMain} text-lg mb-2`}>Objective</h3>
                                  <p className={`${theme.textSub} text-sm`}>
                                      1. Reach <span className={`font-bold ${theme.accentText}`}>10 Points</span> first.<br/>
                                      2. OR Capture the Enemy King (Instant Win).
                                  </p>

                                  <h3 className={`font-bold ${theme.textMain} text-lg mt-6 mb-2`}>The Dice</h3>
                                  <p className={`${theme.textSub} text-sm`}>
                                      Roll at start of every turn.<br/>
                                      <strong>7 or 11:</strong> Draw Power Card.<br/>
                                      <strong>Snake Eyes (1-1):</strong> Lose 1 Point.
                                  </p>
                              </div>
                              
                              <div>
                                  <h3 className={`font-bold ${theme.textMain} text-lg mb-2`}>Scoring System</h3>
                                  <div className="space-y-2 text-sm">
                                      <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture Queen</span> <span className={`font-bold ${theme.accentText}`}>+2</span></div>
                                      <div className="flex justify-between border-b border-white/10 pb-1"><span>Put King in Check</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                                      <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 3 Pawns (Streak)</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                                      <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 4 Pawns (Total)</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                                      <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 2 Majors (Streak)</span> <span className={`font-bold ${theme.accentText}`}>+1</span></div>
                                      <div className="flex justify-between border-b border-white/10 pb-1"><span>Capture 3 Majors (Total)</span> <span className={`font-bold ${theme.accentText}`}>+2</span></div>
                                  </div>
                              </div>
                          </div>

                          <div className="border-t border-white/10 pt-6">
                              <h3 className={`font-bold ${theme.textMain} text-lg mb-4`}>Movement Guide</h3>
                              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                                  {/* Pawn */}
                                  <div className="flex gap-4 items-start">
                                      <MiniBoard piece="P" moves={[[0,-1],[0,1],[-1,0],[-1,-1],[-1,1]]} theme={theme} />
                                      <div>
                                          <div className={`font-bold ${theme.textMain}`}>Pawn</div>
                                          <p className={`text-[10px] ${theme.textSub} mt-1 leading-relaxed`}>
                                              5 Directions: Forward, Diagonals, or Sides. Promotes to Queen.
                                          </p>
                                      </div>
                                  </div>

                                  {/* Knight */}
                                  <div className="flex gap-4 items-start">
                                      <MiniBoard piece="N" moves={[[-2,0],[2,0],[0,-2],[0,2],[-2,-2],[-2,2],[2,-2],[2,2]]} theme={theme} />
                                      <div>
                                          <div className={`font-bold ${theme.textMain}`}>Knight</div>
                                          <p className={`text-[10px] ${theme.textSub} mt-1 leading-relaxed`}>
                                              "The Hopper": Jumps exactly 2 squares. Can jump over pieces.
                                          </p>
                                      </div>
                                  </div>

                                  {/* Bishop */}
                                  <div className="flex gap-4 items-start">
                                      <MiniBoard piece="B" moves={[[-1,-1],[-2,-2],[-3,-3], [-1,1],[-2,2],[-3,3], [1,-1],[2,-2],[3,-3], [1,1],[2,2],[3,3]]} theme={theme} />
                                      <div>
                                          <div className={`font-bold ${theme.textMain}`}>Bishop</div>
                                          <p className={`text-[10px] ${theme.textSub} mt-1 leading-relaxed`}>
                                              Diagonals only. Max 3 squares.
                                          </p>
                                      </div>
                                  </div>

                                  {/* Rook */}
                                  <div className="flex gap-4 items-start">
                                      <MiniBoard piece="R" moves={[[-1,0],[-2,0],[-3,0], [1,0],[2,0],[3,0], [0,-1],[0,-2],[0,-3], [0,1],[0,2],[0,3]]} theme={theme} />
                                      <div>
                                          <div className={`font-bold ${theme.textMain}`}>Rook</div>
                                          <p className={`text-[10px] ${theme.textSub} mt-1 leading-relaxed`}>
                                              Straights only. Max 3 squares.
                                          </p>
                                      </div>
                                  </div>

                                  {/* Queen */}
                                  <div className="flex gap-4 items-start">
                                      <MiniBoard piece="Q" moves={[[-1,0],[-2,0],[-3,0], [1,0],[2,0],[3,0], [0,-1],[0,-2],[0,-3], [0,1],[0,2],[0,3], [-1,-1],[-2,-2],[-3,-3], [-1,1],[-2,2],[-3,3], [1,-1],[2,-2],[3,-3], [1,1],[2,2],[3,3]]} theme={theme} />
                                      <div>
                                          <div className={`font-bold ${theme.textMain}`}>Queen</div>
                                          <p className={`text-[10px] ${theme.textSub} mt-1 leading-relaxed`}>
                                              Combines Rook + Bishop. Max 3 squares.
                                          </p>
                                      </div>
                                  </div>

                                  {/* King */}
                                  <div className="flex gap-4 items-start">
                                      <MiniBoard piece="K" moves={[[-1,-1],[-1,0],[-1,1], [0,-1],[0,1], [1,-1],[1,0],[1,1]]} theme={theme} />
                                      <div>
                                          <div className={`font-bold ${theme.textMain}`}>King</div>
                                          <p className={`text-[10px] ${theme.textSub} mt-1 leading-relaxed`}>
                                              Standard 1 square in any direction.
                                          </p>
                                      </div>
                                  </div>
                              </div>
                          </div>
                           
                           {/* Power Card Usage & Glossary */}
                          <div className="border-t border-white/10 pt-6">
                            <h3 className={`font-bold ${theme.textMain} text-lg mb-2`}>Power Cards</h3>
                            <p className={`${theme.textSub} text-sm mb-4 leading-relaxed`}>
                                <strong>How to Use:</strong> You can hold up to 2 cards. Click a card in your hand during your turn to activate it. 
                                Some cards act immediately (like <em>Jackpot</em>), while others require you to click a target on the board (like <em>Bust</em>).
                            </p>
                            
                            <h4 className={`font-bold ${theme.textMain} text-sm uppercase tracking-wider mb-4 opacity-80`}>Deck Glossary (36 Cards Total)</h4>
                            <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                                {DECK_DISTRIBUTION.map((dist, i) => {
                                    const card = CARD_DEFINITIONS[dist.type];
                                    return (
                                        <div key={i} className="flex justify-center">
                                            <PlayingCard card={card} disabled={true} scale={0.9} badge={`x${dist.count}`} />
                                        </div>
                                    );
                                })}
                            </div>
                          </div>
                      </div>
                  </Modal>
              )}

              {activeModal === 'deck' && (
                  <Modal title="Deck Composition (36 Cards)" onClose={() => setActiveModal(null)} theme={theme} wide={true}>
                      <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                          {DECK_DISTRIBUTION.map((dist, i) => {
                              const card = CARD_DEFINITIONS[dist.type];
                              return (
                                  <div key={i} className="flex justify-center">
                                      <PlayingCard card={card} disabled={true} badge={`x${dist.count}`} />
                                  </div>
                              );
                          })}
                      </div>
                  </Modal>
              )}

              {activeModal === 'audit' && (
                  <Modal title={auditTarget === 'discard' ? "Graveyard (Used Cards)" : `${auditTarget.toUpperCase()} Score Audit`} onClose={() => setActiveModal(null)} theme={theme}>
                      {auditTarget === 'discard' ? (
                          discardPile.length === 0 ? <div className="text-center italic opacity-50">No cards played yet.</div> : (
                              <div className="grid grid-cols-3 gap-4 p-2">
                                  {discardPile.slice().reverse().map((c, i) => (
                                      <div key={i} className="flex justify-center">
                                          <PlayingCard card={c} disabled={true} scale={0.9} />
                                      </div>
                                  ))}
                              </div>
                          )
                      ) : (
                          scoreLogs[auditTarget].length === 0 ? (
                              <div className="text-center opacity-50 italic py-4">No points scored yet.</div>
                          ) : (
                              <table className="w-full text-left text-sm">
                                  <thead>
                                      <tr className="border-b border-white/10 opacity-50"><th className="pb-2">Turn</th><th className="pb-2">Reason</th><th className="pb-2 text-right">Points</th></tr>
                                  </thead>
                                  <tbody>
                                      {scoreLogs[auditTarget].map((log, i) => (
                                          <tr key={i} className="border-b border-white/5">
                                              <td className="py-2 opacity-50">{log.turn}</td>
                                              <td className="py-2">{log.reason}</td>
                                              <td className={`py-2 text-right font-bold ${log.points > 0 ? 'text-green-400' : 'text-red-400'}`}>{log.points > 0 ? '+' : ''}{log.points}</td>
                                          </tr>
                                      ))}
                                  </tbody>
                              </table>
                          )
                      )}
                  </Modal>
              )}

            </div>
          );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<VegasChess />);
    </script>
</body>
</html>
